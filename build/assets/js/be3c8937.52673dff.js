"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics=globalThis.webpackChunkphysical_ai_humanoid_robotics||[]).push([[129],{5546:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"modules/module-1-ros2/urdf-humanoid","title":"URDF Basics for Humanoid Robots","description":"Introduction","source":"@site/docs/modules/module-1-ros2/03-urdf-humanoid.mdx","sourceDirName":"modules/module-1-ros2","slug":"/modules/module-1-ros2/urdf-humanoid","permalink":"/docs/modules/module-1-ros2/urdf-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/modules/module-1-ros2/03-urdf-humanoid.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"URDF Basics for Humanoid Robots","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"rclpy: Bridging Python Agents to ROS 2","permalink":"/docs/modules/module-1-ros2/rclpy-python-agent"},"next":{"title":"Module 2: Digital Twin (Gazebo & Unity)","permalink":"/docs/modules/module-2-digital-twin/"}}');var s=e(4848),l=e(8453);const r={sidebar_label:"URDF Basics for Humanoid Robots",sidebar_position:3},t="URDF Basics for Humanoid Robots",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding URDF Structure",id:"understanding-urdf-structure",level:2},{value:"Basic URDF Elements",id:"basic-urdf-elements",level:2},{value:"Link Definition",id:"link-definition",level:3},{value:"Joint Definition",id:"joint-definition",level:3},{value:"Humanoid Robot Skeleton",id:"humanoid-robot-skeleton",level:2},{value:"Example Humanoid URDF Fragment",id:"example-humanoid-urdf-fragment",level:3},{value:"Joint Types for Humanoid Robots",id:"joint-types-for-humanoid-robots",level:2},{value:"Revolute Joints",id:"revolute-joints",level:3},{value:"Continuous Joints",id:"continuous-joints",level:3},{value:"Prismatic Joints",id:"prismatic-joints",level:3},{value:"Fixed Joints",id:"fixed-joints",level:3},{value:"Visual and Collision Properties",id:"visual-and-collision-properties",level:2},{value:"Geometry Types",id:"geometry-types",level:3},{value:"Materials",id:"materials",level:3},{value:"Inertial Properties",id:"inertial-properties",level:2},{value:"Gazebo Integration",id:"gazebo-integration",level:2},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:2},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Degrees of Freedom",id:"degrees-of-freedom",level:3},{value:"Sensor Integration",id:"sensor-integration",level:3},{value:"URDF Tools and Validation",id:"urdf-tools-and-validation",level:2},{value:"xacro",id:"xacro",level:3},{value:"Validation",id:"validation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"RAG Summary",id:"rag-summary",level:2},{value:"Knowledge Check",id:"knowledge-check",level:2}];function c(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"urdf-basics-for-humanoid-robots",children:"URDF Basics for Humanoid Robots"})}),"\n",(0,s.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(i.p,{children:"Unified Robot Description Format (URDF) is an XML-based format used in ROS to describe robot models. For humanoid robots, URDF defines the physical structure, kinematic relationships, and visual properties. This chapter covers the fundamentals of URDF with a focus on humanoid robot applications."}),"\n",(0,s.jsx)(i.h2,{id:"understanding-urdf-structure",children:"Understanding URDF Structure"}),"\n",(0,s.jsx)(i.p,{children:"A URDF file describes a robot as a collection of links connected by joints. The basic structure includes:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Links"}),": Rigid bodies with physical properties"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Joints"}),": Connections between links with kinematic properties"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Visual"}),": How the robot appears in simulation"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Collision"}),": How the robot interacts physically"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Inertial"}),": Mass properties for physics simulation"]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"basic-urdf-elements",children:"Basic URDF Elements"}),"\n",(0,s.jsx)(i.h3,{id:"link-definition",children:"Link Definition"}),"\n",(0,s.jsx)(i.p,{children:"A link represents a rigid body in the robot:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    <mass value="1.0"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n  </inertial>\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="1 1 1"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 1 1"/>\n    </material>\n  </visual>\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="1 1 1"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(i.h3,{id:"joint-definition",children:"Joint Definition"}),"\n",(0,s.jsx)(i.p,{children:"Joints connect links and define their movement:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link"/>\n  <child link="child_link"/>\n  <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,s.jsx)(i.h2,{id:"humanoid-robot-skeleton",children:"Humanoid Robot Skeleton"}),"\n",(0,s.jsx)(i.p,{children:"A humanoid robot typically includes these main components:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Torso"}),": Main body with head, arms, and legs attached"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Head"}),": With sensors like cameras and IMU"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Arms"}),": Shoulders, elbows, wrists, and hands"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Legs"}),": Hips, knees, ankles, and feet"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"example-humanoid-urdf-fragment",children:"Example Humanoid URDF Fragment"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_robot">\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <inertial>\n      <mass value="5.0"/>\n      <origin xyz="0 0 0.3"/>\n      <inertia ixx="0.5" ixy="0.0" ixz="0.0" iyy="0.5" iyz="0.0" izz="0.3"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.3"/>\n      <geometry>\n        <capsule radius="0.15" length="0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.3"/>\n      <geometry>\n        <capsule radius="0.15" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint connecting base to torso --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 0.1"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1"/>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1"/>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint connecting torso to head --\x3e\n  <joint name="torso_to_head" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10" velocity="1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,s.jsx)(i.h2,{id:"joint-types-for-humanoid-robots",children:"Joint Types for Humanoid Robots"}),"\n",(0,s.jsx)(i.h3,{id:"revolute-joints",children:"Revolute Joints"}),"\n",(0,s.jsx)(i.p,{children:"Allow rotation around a single axis - ideal for:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Shoulder joints (pitch, roll, yaw)"}),"\n",(0,s.jsx)(i.li,{children:"Elbow joints (flexion/extension)"}),"\n",(0,s.jsx)(i.li,{children:"Knee joints (flexion/extension)"}),"\n",(0,s.jsx)(i.li,{children:"Hip joints (multiple axes)"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"continuous-joints",children:"Continuous Joints"}),"\n",(0,s.jsx)(i.p,{children:"Like revolute joints but without limits - useful for:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Rotating joints that need full rotation"}),"\n",(0,s.jsx)(i.li,{children:"Continuous rotation wheels"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"prismatic-joints",children:"Prismatic Joints"}),"\n",(0,s.jsx)(i.p,{children:"Allow linear motion - used for:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Linear actuators"}),"\n",(0,s.jsx)(i.li,{children:"Telescoping mechanisms"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"fixed-joints",children:"Fixed Joints"}),"\n",(0,s.jsx)(i.p,{children:"Connect links without allowing motion - used for:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Attaching sensors"}),"\n",(0,s.jsx)(i.li,{children:"Connecting rigid components"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"visual-and-collision-properties",children:"Visual and Collision Properties"}),"\n",(0,s.jsx)(i.h3,{id:"geometry-types",children:"Geometry Types"}),"\n",(0,s.jsx)(i.p,{children:"URDF supports several geometry types:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Box --\x3e\n<geometry>\n  <box size="0.1 0.2 0.3"/>\n</geometry>\n\n\x3c!-- Cylinder --\x3e\n<geometry>\n  <cylinder radius="0.1" length="0.2"/>\n</geometry>\n\n\x3c!-- Sphere --\x3e\n<geometry>\n  <sphere radius="0.1"/>\n</geometry>\n\n\x3c!-- Mesh --\x3e\n<geometry>\n  <mesh filename="package://robot_description/meshes/link.stl"/>\n</geometry>\n'})}),"\n",(0,s.jsx)(i.h3,{id:"materials",children:"Materials"}),"\n",(0,s.jsx)(i.p,{children:"Materials define the visual appearance:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<material name="red">\n  <color rgba="1 0 0 1"/>\n</material>\n<material name="blue">\n  <color rgba="0 0 1 1"/>\n</material>\n<material name="green">\n  <color rgba="0 1 0 1"/>\n</material>\n'})}),"\n",(0,s.jsx)(i.h2,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,s.jsx)(i.p,{children:"Inertial properties are crucial for physics simulation:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<inertial>\n  <mass value="1.0"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n</inertial>\n'})}),"\n",(0,s.jsx)(i.p,{children:"For simple shapes, you can calculate inertial properties:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Box: Ixx = m/12 * (h\xb2 + d\xb2), Iyy = m/12 * (w\xb2 + d\xb2), Izz = m/12 * (w\xb2 + h\xb2)"}),"\n",(0,s.jsx)(i.li,{children:"Cylinder: Ixx = Iyy = m/12 * (3r\xb2 + h\xb2), Izz = m/2 * r\xb2"}),"\n",(0,s.jsx)(i.li,{children:"Sphere: Ixx = Iyy = Izz = 2/5 * m * r\xb2"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"gazebo-integration",children:"Gazebo Integration"}),"\n",(0,s.jsx)(i.p,{children:"To use URDF in Gazebo, add Gazebo-specific tags:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  <material>Gazebo/Blue</material>\n  <mu1>0.9</mu1>\n  <mu2>0.9</mu2>\n</gazebo>\n\n<gazebo>\n  <plugin name="robot_state_publisher" filename="libgazebo_ros_robot_state_publisher.so">\n    <tf_prefix>robot</tf_prefix>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,s.jsx)(i.h2,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,s.jsx)(i.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Center of mass should be low and within the support polygon"}),"\n",(0,s.jsx)(i.li,{children:"Proper weight distribution between upper and lower body"}),"\n",(0,s.jsx)(i.li,{children:"Appropriate foot size for stability"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"degrees-of-freedom",children:"Degrees of Freedom"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Humanoid robots typically have 20-30+ degrees of freedom"}),"\n",(0,s.jsx)(i.li,{children:"Each joint adds complexity to control algorithms"}),"\n",(0,s.jsx)(i.li,{children:"Consider underactuated vs. fully actuated designs"}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Cameras in the head for vision"}),"\n",(0,s.jsx)(i.li,{children:"IMU in the torso for balance"}),"\n",(0,s.jsx)(i.li,{children:"Force/torque sensors in feet and hands"}),"\n",(0,s.jsx)(i.li,{children:"Joint position/velocity/torque sensors"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"urdf-tools-and-validation",children:"URDF Tools and Validation"}),"\n",(0,s.jsx)(i.h3,{id:"xacro",children:"xacro"}),"\n",(0,s.jsx)(i.p,{children:"xacro is a macro language that simplifies complex URDF files:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid">\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n\n  <xacro:macro name="simple_link" params="name mass xyz">\n    <link name="${name}">\n      <inertial>\n        <mass value="${mass}"/>\n        <origin xyz="${xyz}"/>\n        <inertia ixx="1" ixy="0" ixz="0" iyy="1" iyz="0" izz="1"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  <xacro:simple_link name="my_link" mass="1.0" xyz="0 0 0"/>\n</robot>\n'})}),"\n",(0,s.jsx)(i.h3,{id:"validation",children:"Validation"}),"\n",(0,s.jsx)(i.p,{children:"Always validate your URDF:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Check for proper XML syntax"}),"\n",(0,s.jsx)(i.li,{children:"Verify all links are connected"}),"\n",(0,s.jsx)(i.li,{children:"Ensure joint limits are reasonable"}),"\n",(0,s.jsx)(i.li,{children:"Validate inertial properties"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Use consistent naming conventions"}),"\n",(0,s.jsx)(i.li,{children:"Start with simple models and add complexity gradually"}),"\n",(0,s.jsxs)(i.li,{children:["Validate URDF with tools like ",(0,s.jsx)(i.code,{children:"check_urdf"})]}),"\n",(0,s.jsx)(i.li,{children:"Use xacro for complex robots to avoid duplication"}),"\n",(0,s.jsx)(i.li,{children:"Consider the physics implications of your design"}),"\n",(0,s.jsx)(i.li,{children:"Test in simulation before building physical robots"}),"\n",(0,s.jsx)(i.li,{children:"Document your URDF structure for maintainability"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"rag-summary",children:"RAG Summary"}),"\n",(0,s.jsx)(i.p,{children:"URDF (Unified Robot Description Format) is an XML-based format for describing robot models in ROS. For humanoid robots, it defines links (rigid bodies) connected by joints with specific kinematic properties. Key elements include links with inertial, visual, and collision properties, and joints that define movement between links. Proper URDF design is crucial for accurate physics simulation and robot control in humanoid applications."}),"\n",(0,s.jsx)(i.h2,{id:"knowledge-check",children:"Knowledge Check"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"What are the main components of a URDF file?"}),"\n",(0,s.jsx)(i.li,{children:"What is the difference between visual and collision properties in URDF?"}),"\n",(0,s.jsx)(i.li,{children:"What are the different joint types available in URDF?"}),"\n",(0,s.jsx)(i.li,{children:"How do you define inertial properties for a robot link?"}),"\n",(0,s.jsx)(i.li,{children:"What is xacro and why is it useful for complex URDFs?"}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,l.R)(),...n.components};return i?(0,s.jsx)(i,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>r});var o=e(6540);const s={},l=o.createContext(s);function r(n){const i=o.useContext(l);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}}}]);